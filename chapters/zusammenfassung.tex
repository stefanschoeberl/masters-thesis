\chapter{Zusammenfassung}

In diesem Kapitel werden die Ergebnisse der Arbeit zusammengefasst und es wird ein Ausblick auf mögliche Erweiterungen des MiniJava-Compilers und alternative Ansätze gegeben. Zum Schluss gebe ich einen Einblick auf meine persönlichen Erfahrungen während der Entwicklung des Compilers.

\section{Ergebnisse}

Alle vier Fragen der Problemstellung wurden in dieser Arbeit beantwortet:
\begin{enumerate}
	\item Was ist WebAssembly, welche Möglichkeiten bietet WebAssembly und welche Einschränkungen gibt es?
	\item Wie kann ein Compiler, der eine Programmiersprache nach WebAssembly übersetzt, implementiert und getestet werden?
	\item Wie werden typische Sprachkonstrukte einer Programmiersprache auf Web\-Assem\-bly-Befehle abgebildet?
	\item Wie wird die Schnittstelle zum Browser entworfen und auf welche Aspekte muss dabei geachtet werden?
\end{enumerate}

Zu Beginn wurde im \ref{cha:Technische-Grundlagen} Kapitel (Technischen Grundlagen) WebAssembly als Technologie detailliert behandelt. Weiters wurden drei Technolgien (Emscripten, Rust und Blazor) vorgestellt, die bereits auf WebAssembly aufbauen. Dabei wurden auch einige Einschränkungen von WebAssembly dargestellt, beispielsweise kann nicht zu jeder beliebigen Instruktion gesprungen werden, da Sprünge strukturiert sein müssen. Weiters wurde ein Ausblick auf weitere Entwicklungen von WebAssembly gegeben. In den technischen Grundlagen wurden außerdem diverse Technologien behandelt, die für die Implementierung notwendig sind, wie beispielsweise ANTLR und Kotlin. Hier wurde die erste Frage der Problemstellung beantwortet.

In Kapitel \ref{cha:MiniJava} wurde die Programmiersprache MiniJava vorgestellt, für die der Compiler entwickelt wurde. Weiters wurde auf die Anforderungen an das Laufzeitsystem eingegangen.

Die zweite Frage wurde in den Kapiteln \ref{cha:Codegenerierung-für-WebAssembly} und \ref{cha:Testen-des-Compilers} beantwortet. Hier wurde gezeigt, wie die Sprachkonstrukte aus MiniJava auf WebAssembly-Bytecode abgebildet werden und wie der Compiler getestet wird. JavaScript-Aspekte, die zur Laufzeit notwendig sind, wurden in Kapitel \ref{cha:JavaScript-Integration} dargestellt. Dazu zählt beispielsweise die Objektverwaltung.

Zum Schluss wurde die Funktionalität des gesamten Systems anhand einer Demo-Anwendung, dem Fibonacci-Rechner, in Kapitel \ref{cha:DemoAnwendung} gezeigt. Weiters wurde Frage 4 mit einem Einblick in die Standardbibliothek für Browser-Zugriffe beantwortet. Der Zugriff erfolgt über native Methoden, die in MiniJava aufgerufen werden können, deren Implementierung aber in JavaScript hinterlegt ist.

Alle Vorhaben wurden umgesetzt und die Implementierung des Compilers ist gelungen. MiniJava kann in eigenen Projekten für Browser-Anwendungen eingesetzt werden. Die Integration in bestehende Systeme ist ebenfalls möglich.

\section{Ausblick}

Während dem Erstellen der gesamten Arbeit sind einige interessante Ideen und Ansätze entstanden, die aber leider nicht umgesetzt wurden, da sie schlicht und einfach den Rahmen der Arbeit gesprengt hätten. Nachfolgend findet sich eine Liste all dieser Ideen und Ansätze:
\begin{itemize}
    \item Bessere Integration des JavaScript-Garbage-Collectors: Derzeit werden alle in MiniJava verwendete Objekte in einer JavaScript-Datenstruktur verwaltet. Die Objete bleiben jedoch in dieser Datenstruktur enthalten, auch wenn sie in nirgends mehr benötigt werden. Sie verbrauchen dadurch unnötig Ressourcen. JavaScript bietet mit einem eigenen Garbage-Collector bereits Fuktionalitäten an, nicht mehr benötigte Ressourcen freizugeben. Diesen könnte man besser integrieren, um so die Ressourcennutzung zu verbessern.
    \item Den gesamten Java-Sprachumfang unterstützen: MiniJava fehlen Funktionalitäten, die in Java enthalten sind, dazu zählen beispielsweise \emph{vollständige Objektorientierung}, dynamische Bindung von Methoden zur Laufzeit, Lambda-Ausdrücke und \emph{Interfaces}. Für all diese Funktionalitäten müsste man entsprechende Abbildungen in WebAssembly finden. Dadurch könnte man schlussendlich im Idealfall auch einen Großteil der Java-Standardbibliothek im Browser einsetzen.
    \item MiniJava-Objekte im WebAssembly-Speicher: Ursprünglich wurden im ersten Entwurf alle MiniJava-Objekte im WebAssembly-Speicher abgelegt. Dieser wurde aber wieder verworfen, da durch die Abbildung auf JavaScript-Objekte der Zugriff auf den DOM signifikant vereinfacht wurde. Aus Performanzsicht wäre es eine Überlegung, dennoch einige Objekte im WebAssembly-Speicher zu verwalten, wenn sie nur MiniJava-intern verwendet werden. Eine einfache Möglichkeit wäre, eine Klasse mit einer eigenen Annotation zu markieren, damit Objekte dieser Klasse nicht mehr auf JavaScript abgebildet werden, sondern im WebAssembly-Speicher abgelegt werden. Eine Annotation mit gegenteiligem Verhalten wäre natürlich auch möglich. So könnte man je nach Anwendungsfall zwischen den beiden Möglichkeiten wählen.
    \item Java-Bytecode konvertieren: Anstatt den gesamten Compiler neu zu erfinden, könnte man versuchen, Java-Bytecode direkt in WebAssembly-Bytecode abzubilden. Da die JVM ebenfalls mit einem Kellerspeicher arbeitet, wären einige Aspekte direkt abbildbar. Andere Aspekte, wie Sprünge zu beliebigen Instruktionen, sind nicht direkt in WebAssembly abbildbar.
    \item Performanz der virtuellen WebAssembly-Maschine: WebAssembly verspricht hohe Performanz. Im Fibonacci-Rechner dieser Arbeit scheint die WebAssembly-Variante schneller zu sein, dies wurde aber nicht genauer erforscht. Daher wären umfangreiche Performanzmessungen interessant, um herauszufinden, um wie viel \emph{besser} WebAssembly im Vergleich zu reinem JavaScript abschneidet.
    \item Testen ausweiten und verbessern: Die Funktionalität des Compilers wurde mit einer großen Menge an Testfällen (zum Zeitpunkt der Fertigstellung der Arbeit über 350) validiert. Sie decken alle Sprachfunktionalitäten ab und waren eine große Hilfe bei größeren Architekturänderungen und Refactorings. Da die Sprache MiniJava unendlich groß ist, können unmöglich alle Randfälle abgedeckt werden. Um daher zumindest den Testumfang zu vergrößeren, wäre das automatische Generieren von Testfällen nützlich. Eine Möglichkeit solche Testfälle zu erzeugen, wäre das \emph{zufällige} Erzeugen von MiniJava-Quelltext basierend auf der Grammatik. Um das erwartete Ergebnis dieses Quelltexts zu erhalten, könnte man ihn mit dem Java-Compiler kompilieren und ausführen.
    \item Zukünftig ist es vielleicht nicht mehr notwendig, gewisse Funktionalitäten, wie beispielsweisen den Zugriff auf JavaScript-Objekte, händisch nachzubauen. WebAssembly ist eine aktiv wachsende Technologie und könnte daher zukünftig solche Funktionalitäten selbst enthalten. Eine weitere interessante Entwicklung ist das \emph{WebAssembly Binary Interface} (WASI) \cite{WASI}, mit der eine einheitliche Schnittstelle zur Umgebung geschaffen werden soll.
\end{itemize}

\section{Persönliche Erfahrung}

Mir hat das Entwickeln eines neuen Compilers einschließlich dem Aufbau des Laufzeitsystems sehr viel Spaß gemacht und hat mir noch bessere Einblicke in die Komplexität des Compilerbaus gegeben. Im 2. Bachelorsemester und 1. Mastersemester Software Engineering wird das Thema Compilerbau in eigenen Lehrveranstaltungen am Beispiel von Teilmengen von Pascal, C und C++ behandelt. Diese Grundlagen waren mehr als ausreichend, um den MiniJava-Compiler zu entwickeln. Da der Sprachumfang von MiniJava jedoch sehr umfangreich ist, war die Architektur und sauberere Strukturierung des Compilers selbst eine neue Herausforderung. Daher war es die richtige Entscheidung von Anfang an auf testgetriebene Entwicklung zu setzen, um Architekturanpassungen im Laufe der Zeit zuverlässig (und ohne große Sorge, \emph{dass etwas kaputt geht}) umsetzen zu können. WebAssembly hat großes Potenzial und bleibt in den nächsten Jahren eine spannende Entwicklung, die es zu beobachten gilt. Besonders interessant werden die zukünftigen Erweiterungen und die Anwendungen von WebAssembly, da sich WebAssembly auf sehr unterschiedliche Arten (wie man bei Emscripten, Rust, Blazor und MiniJava sieht) einsetzen lässt.
