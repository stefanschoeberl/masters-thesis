\chapter{Testen des Compilers und Integration des Compilers in Gradle}

\section{Testen}

Während dem Entwickeln des Compilers muss sichergestellt werden, dass beim Hinzufügen neuer Features, diese wie erwartet funktionieren. Gleichzeitig musste auch gewährleistet werden, dass die bereits bestehende Funktionalität des Compilers nicht (versehentlich) verändert wird.

Grundsätzlich stehen zwei Ansätze zum Testen zur Verfügung:
\begin{enumerate}
    \item Jede Komponente isoliert testen, dies entspricht konzeptionell klassischen Unit-Tests. Hier könnte man testen, ob zum Beispiel die erwünschten Instruktionen für eine Schleife generiert werden. 
    \item Testen, ob ein gegebener MiniJava-Sourcecode nach dem Kompilieren eine erwartete Konsolenausgabe beim Ausführen produziert. Das entspricht konzeptionell eher einem Integrationstest. Dabei werden in jedem Testfall alle Teilprozesse (Kompilieren, Codegenerieren und Ausführen) ausgeführt.
\end{enumerate}

Es wurde der zweite Ansatz gewählt, da er während dem Entwickeln eine größere Flexibilität bietet. Die finale Architektur des Compilers entstand erst im Laufe der Entwicklung. Am Anfang war zu erwarten, dass sich interne Strukturen des Compilers laufend ändern könnten. Klassische Unit-Tests müsste man bei größeren Architekturänderungen oft anpassen. Bei Tests, die den gesamten Prozess vom Kompileren bis zum Ausführen als "Black-Box" betrachten, ist eine Änderung praktisch nicht notwendig, da bei den einzigen zwei Schnittstellen (MiniJava-Sourcecode und Konsolenausgabe) zwischen Implementierung und Tests keine Änderungen zu erwarten sind. Außerdem bilden alle Testfälle gemeinsam eine Art Spezifikation für die Programmiersprache.

Als Testframework wird JUnit 5 \cite{JUnit} in Kombination mit AssertJ \cite{AssertJ} eingesetzt. Nachfolgend sieht man ein Beispiel, für einen einfachen Testfall:

\lstinputlisting{src/testenGradle/simpleTest.kt}

Beim Durchführen des Tests wird im Hintergrund eine Datei (\emph{main.minijava}) mit dem zu testenden MiniJava-Sourcecode angelegt. JUnit 5 bietet die Annotation \lstinline{@TempDir} an, mit der ein temporäres Verzeichnis für jeden Testfall angelegt wird, das nach Ablauf der Tests wieder gelöscht wird \cite{JUnit}. So werden die Testfälle von einander isoliert.

Hilfsfunktionen wie \lstinline{compileAndRunInMainClass} starten den Compiler und führen das erzeugte Modul aus. Am Ende wird die Konsolenausgabe als String zurückgegeben.

Unter Zuhilfenahme von AssertJ lassen sich die erwarteten Ergebnisse fast wie ein englischer Satz elegant formulieren, zum Beispiel: \lstinline{assertThat(...).containsExactly(...)} \cite{AssertJ}.

Es ist auch möglich, native Methoden auf diese Art zu testen. In diesem Fall wird zusätzlich ein Stück JavaScript-Sourcecode mitgegeben. Dieser Sourcecode wird in die Datei \emph{main.js} gespeichert, die ebenfalls im temporären Verzeichnis liegt.

Nachfolgend ein einfaches Beispiel für so einen Testfall:

\lstinputlisting{src/testenGradle/nativeTest.kt}

\section{Gradle-Task und -Plugin}

Es ist möglich, den MiniJava-Compiler direkt zum Beispiel über die Kommandozeile aufzurufen. Für praktische Projekte ist allerdings eine Integration in bestehende Build-Systeme (in diesem Fall Gradle) nützlich, wie es bei anderen Programmiersprachen (zum Beispiel Java und Kotlin) üblich ist.

In der Gradle-Dokumentation \cite{Gradle} wird beschrieben, wie eigene Erweiterungen für Gradle implementiert werden können. Nachfolgend werden die notwendigen Schritte erläutert, die speziell für den MiniJava-Compiler notwendig sind, um ihn in Gradle zu integrieren.

Zunächst wird ein eigener Task (\lstinline{MiniJavaCompilationTask}) definiert, der das Kompilieren von MiniJava-Sourcecode kapselt. Dieser Task ist von \lstinline{JavaExec} abgeleitet. Der \lstinline{JavaExec}-Task wird von Gradle zur Verfügung gestellt und kann -- ähnlich wie die java-Kommandozeile -- kompilierte Bytecode-Klassen ausführen. Im \lstinline{MiniJavaCompilationTask} wird der \lstinline{JavaExec}-Task konfiguriert, damit er die Hauptklasse des Compilers (\lstinline{MainKt}) mit den gewünschten Parametern aufruft:

\lstinputlisting{src/testenGradle/MiniJavaCompilationTask.groovy}

Der \lstinline{MiniJavaCompilationTask} bietet zusätzlich noch die Methoden \lstinline{inputDirs} und \lstinline{outputDir} an, mit denen der Task konfiguriert werden kann. Die Methoden speichern die übergebenen Ordner und leiten daraus die Parameter für den Compiler ab (\lstinline{updateArg}). Über \lstinline{inputs.dir(...)} und \lstinline{outputs.dir(...)} können in Gradle Metainformationen für den Task definiert werden, die beschreiben, von welchen Dateien der Task abhängig ist und welche Dateien der Task produziert. So kann Gradle den Build-Prozess optimieren, indem beispielsweise nur dann der MiniJava-Compiler ausgeführt wird, wenn sich eine MiniJava-Sourcecode-Datei verändert hat

Der \lstinline{JavaExec}-Task benötigt zum Ausführen einen Klassenpfad, in dem die MiniJava-Compiler-Klassen enthalten sind. Dieser Klassenpfad besitzt einen eigenen Namen (\lstinline{project.configurations.minijava}) und ist unabhängig von anderen, die in Gradle definiert sind (wie beispielsweise \lstinline{implementation}, \lstinline{testImplementation} und \lstinline{compileOnly})

Der \lstinline{minijava}-Klassenpfad muss daher zunächst im Gradle-Projekt definiert werden. Dies ist mit Hilfe eines eigenen Plugins möglich:

\lstinputlisting{src/testenGradle/MiniJavaPlugin.groovy}

Damit andere Gradle-Projekte das Plugin finden, gibt es mehrere Möglichkeiten. Bei der hier eingesetzten Variante genügt es, im Gradle-Wurzelprojekt einen Ordner \lstinline{buildSrc} zu erstellen, in dem der Sourcecode vom Task und Plugin gemäß folgender Ordnerstruktur abgelegt wird:

\lstinputlisting{src/testenGradle/buildSrc.txt}

Weiters ist darin die Datei \emph{dev.ssch.minijava.properties} notwendig, in der der Name der Plugin-Klasse definiert wird:

\lstinputlisting{src/testenGradle/dev.ssch.minijava.properties}

\lstinline{dev.ssch.minijava} im Dateinamen dieser Datei ist der Bezeichner, unter dem das Plugin von anderen Gradle-Projekten gefunden werden kann.

\section{Integration von MiniJava in eine Node.js-Konsolenanwendung}
\label{sec:NodeJSExample}

Auf Basis der Vorbereitungen im vorherigen Abschnitt kann der Compiler nun in eigenen Projekten eingesetzt werden. Nachfolgend wird die Konfiguration in Gradle, sowie das Einbinden in eine Node.js-Konsolenanwendung demonstriert.

Das Projekt ist folgendermaßen strukturiert:

\lstinputlisting{src/testenGradle/demo-nodejs.txt}

In der Datei \emph{build.gradle} wird folgende Konfiguration vorgenommen:

\lstinputlisting{src/testenGradle/build.gradle}

Nachfolgend einige Erklärungen zu \emph{build.gradle}:
\begin{enumerate}
    \item Plugin mit dem im vorherigen Abschnitt definierten Bezeichner aktiveren.
    \item Compiler in den Klassenpfad \lstinline{minijava} legen.
    \item Task instanzieren und mit zwei Quellcode-Verzeichnissen (Standardbibliothekund das minijava-Verzeichnis) und dem Ausgabe-Verzeichnis (build/wasm-module) parametrisieren.
\end{enumerate}

Die Standardbibliothek befindet sich außerhalb des Projektverzeichnisses befindet, 

In der Datei \emph{index.js} kann nun das kompilierte MiniJava-Modul, wie in Node.js üblich, mit \lstinline{require} importiert und anschließend aufgerufen werden:

\lstinputlisting{src/testenGradle/index.js}

Das Projekt kann nun mit \lstinline{node index.js} gestartet werden.
