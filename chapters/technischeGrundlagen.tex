\chapter{Technische Grundlagen}

\section{WebAssembly}
\subsection{Hintergrund und Motivation}
\subsection{Konzepte}
\subsection{WebAssembly-Module}
\subsection{Aktueller Entwicklungsstand}
\subsection{WebAssembly Binary Toolkit}
\subsection{JavaScript-API}

\section{ANTLR}
\subsection{Hintergrund}
\subsection{Grundkonzepte}
\subsection{Grammatikbeschreibung}

\section{Weitere Technologien}
\subsection{Kotlin}
\subsection{Node.js}
\subsection{JavaScript}
\subsection{Gradle}
\subsection{webpack}
\pagebreak % TODO: remove
\section{Stand der Technik}
Es gibt bereits eine Reihe an Technologien, die auf WebAssembly aufbauen. In diesem Abschnitt werden drei ausgewählte aktuelle Technologien betrachtet. Es wird dabei der Fokus auf den Einsatz der Technologien und der Art der Integration mit WebAssembly und JavaScript gelegt.

\subsection{Emscripten}

\subsection{Blazor WebAssembly}
Blazor \cite{Blazor} ist ein von Microsoft entwickeltes Framework und eine Technologie in der ASP.NET Core Familie. Mit Blazor lassen sich clientseitige Web-Anwendungen auf Basis von .NET mit C\#{} entwickeln. Blazor wird in zwei Ausprägungen angeboten: Blazor Server und Blazor WebAssembly. Weitere Ausprägungen für Progressive-Web-Apps, mobile Anwendungen auf Basis von Web-Technologien und native Anwendungen sind geplant \cite{BlazorBlog}.

Blazor basiert auf Razor \cite{Razor}. Razor ermöglicht, HTML und C\#{} miteinander zu kombinieren. Nachfolgend ist ein Code-Beispiel, das das Zusammenspiel zwischen HTML und C\#{} verdeutlichen soll.

\lstinputlisting[caption = Beispiel für eine Blazor-Komponente aus der offiziellen Dokumenation \cite{Blazor}]{src/technischeGrundlagen/blazorExample.razor}

Man sieht, dass sich Werte aus Variablen ausgeben lassen können (\lstinline{@Title}) und Maus\-klick-Ereignisse auf Methodenaufrufe abgebildet werden können (\lstinline{@onclick="OnYes"}). Weiters lassen sich andere Komponenten einbinden (\lstinline{@ChildContent}).

Blazor Server wird, wie der Name bereits erahnen lässt, serverseitig betrieben. Dabei läuft die Logik der Web-Anwendung auf dem Server. Die Kommunikation zwischen Server und Browser erfolgt über SignalR. Das bedeutet, dass jedes Ereignis und jedes Update der Benutzeroberfläche über das Netzwerk erfolgt. Blazor Server wurde hier nur zur Vollständigkeit erwähnt und wird nicht weiter behandelt.

Bei der zweiten Variante, Blazor WebAssembly, wird keine Logik mehr am Server ausgeführt. Der Weg vom Code zur lauffähigen Anwendung sieht folgendermaßen aus: Der Code wird zu .NET-Assemblies kompiliert. Der Browser lädt diese Assemblies und die .NET-Laufzeit-Umgebung von einem Web-Server herunter. Die .NET-Lauf\-zeit\-um\-ge\-bung läuft in der virtuellen WebAssembly-Maschine und lädt die Assemblies. In diesem Prozess gibt es eine Reihe an Optimierungen, zum Beispiel wird die .NET-Laufzeitumgebung im Cache des Browsers ablegt, um unnötige Downloads zu ersparen.

Blazor basiert auf dem .NET Standard 2.0. Somit kann bestehender Code, der diesen Standard erfüllt, wiederverwendet werden. Gewisse Funktionaliäten dieses Standards werden jedoch nicht unterstützt, dazu zählt beispielsweise direkter Dateisystemzugriff und Threading. In diesen Fällen kommt es zu einem Laufzeitfehler.

Weiters bietet Blazor Schnittstellen an, um von JavaScript ausgehend .NET-Methoden aufzurufen und umgekehrt. Nachfolgend finden sich zwei Codeausschnitte, die die Interoperabilität veranschaulichen sollen. Sie basieren auf der offiziellen Dokumentation und wurden auf die wesentlichen Bestandteile zusammengefasst.

\lstinputlisting[caption = Aufruf einer JavaScript-Funktion in C\#{} \cite{Blazor}]{src/technischeGrundlagen/blazorJSCalls.txt}

\lstinputlisting[caption = Aufruf einer C\#{}-Methode in JavaScript \cite{Blazor}]{src/technischeGrundlagen/blazorCSharpCall.txt}

\subsection{Rust}

Die Programmiersprache Rust verspricht auf der eigenen Website \cite{RustWasmWebsite} Unterstützung für WebAssembly. Dabei werden sticht besonders hervor, dass zur Laufzeit kein Garbage-Collector involviert ist, die Ausführzeiten somit vorhersehbar werden und der Rust-Compiler in der Lage ist, möglichst kleine WebAssembly-Module zu generieren.

Der Weg vom Rust-Code zur Webanwendung sieht folgendermaßen aus: Der Rust-Sourcecode wird mit cargo in ein WebAssembly-Modul kompiliert. Anschließend wird mit wasm-bindgen JavaScript-Code generiert. Das Werkzeug wasm-pack fasst diese Aufgaben zusammen \cite{RustWasmBook}.

Um Rust-Sourcecode im WebAssembly-Umfeld verwenden zu können, sind einige Anpassungen im Code notwendig. Nachfolgend findet sich ein einfaches Code-Beispiel (basierend auf der offiziellen Dokumentation \cite{RustWasmBook}), das die Interopabilität zwischen Rust und JavaScript demonstrieren soll.

\lstinputlisting[caption = Rust-Sourcecode für WebAssembly angepasst]{src/technischeGrundlagen/rustLib.rs}

Zunächst muss die Speicherverwaltung konfiguriert werden. Dafür wird \lstinline{wee_alloc} (The Wasm-Enabled, Elfin Allocator) eingesetzt. Dieser erzeugt besonders wenig WebAs\-sembly-Bytecode, laut offizieller Dokumentation unter einem Kilobyte und ist für WebAssembly ausgelegt \cite{WeeAlloc}.

Mit dem Attribut \lstinline{#[wasm_bindgen]} können Funktionalitäten von JavaScript importiert (hier die Funktion \lstinline{alert} in Kombination mit \lstinline{extern}) werden. Es ist auch möglich, Datenstrukturen und Funktionen für JavaScript zugänglich zu machen (hier die Datenstruktur \lstinline{Point} und die Funktionen \lstinline{Point.new} und \lstinline{alert_point}).

Aus diesen Informationen kann wasm-pack JavaScript-Code erzeugen, der sehr einfach verwendet werden kann:

\lstinputlisting[caption = Verwendung eines Rust-Moduls in JavaScript ]{src/technischeGrundlagen/rustJS.js}

Sämtliche Daten (wie die Instanz der Struktur \lstinline{Point}) werden im eigenen Speicherbereich für WebAssembly abgelegt (siehe Abschnit TODO). Es wird nur die Adresse des hinterlegten Rust-Objekts in einem JavaScript-Objekt gekapselt. Dieses JavaScript-Objekt delegiert sämtliche Funktionsaufrufe an WebAssembly.
