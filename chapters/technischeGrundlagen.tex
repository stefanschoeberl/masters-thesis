\chapter{Technische Grundlagen}

\section{WebAssembly}
\subsection{Hintergrund und Motivation}
WebAssembly ist ein Bytecode mit dem Ziel, eine sprachunabhängige Plattform fürs Web zu schaffen \cite{WebAssemblyWebsite} \cite{WebAssemblySpecification}. So können "neue" Programmiersprachen (wie zum Beispiel C, C++ oder Rust) und hochperformanter Code ins Web gebracht werden.

Da Browser ausschließlich JavaScript unterstützen, musste bisher der Sourcecode anderer Programmiersprachen mit einen Transpiler in JavaScript konvertiert werden. Beispielsweise übernimmt bei TypeScript diese Aufgabe der TypeScript Compiler \cite{TypeScript}.

JavaScript muss im Browser zur Laufzeit interpretiert werden, gegenbenfalls wird Just-In-Time kompiliert \cite{MDNJavaScript}. Dies ist natürlich mit einem gewissen Mehraufwand verbunden. Hier verspricht WebAssembly Performanceverbesserungen, da der Bytecode einfacher geladen werden kann (verglichen mit dem Parsen einer Skriptsprache) \cite{WebAssemblySpecification}.

Man könnte auf den ersten Blick vermuten, dass WebAssembly etwas mit "Assembler" aufgrund des ähnlichen Namen gemeinsam hat und man sich daher Gedanken zur Sicherheit machen könnte. Hier gibt WebAssembly ein klares Sicherheitsmodell vor: Vereinfacht gesagt läuft sämtlicher WebAssembly-Bytecode im Browser in einer isolierten Umgebung und besitzt nicht mehr Rechte beim Ausführen als klassischer JavaScript-Code \cite{WebAssemblyWebsite}.

Im Rahmen eines MVP (Minimum Viable Product) entstand die erste Version für WebAssembly, in der nur die notwendigsten Funktionalitäten implementiert wurden, um mit WebAssembly überhaupt arbeiten zu können. \cite{WebAssemblyWebsite}. WebAssembly wird seit 2017 in den vier großen Browsern (Mozilla Firefox, Google Chrome, Apple Safari und Microsoft Edge) unterstützt. 

WebAssembly trifft in der Spezifikation keine Annahmen zur Laufzeitumgebung. Auch wenn das primäre Einsatzgebiet das Web ist, ist es durchaus denkbar, dass WebAssembly andersweitig eingesetzt wird. WebAssembly wurde auch so entworfen, dass nicht einmal JavaScript für die Laufzeitumgebung notwendig sein müsste \cite{WebAssemblyWebsite}.

\subsection{Konzepte}
\subsection{WebAssembly-Module}
\subsection{Aktueller Entwicklungsstand}
\subsection{WebAssembly Binary Toolkit}
\subsection{JavaScript-API}

\section{ANTLR}
\subsection{Hintergrund}
\subsection{Grundkonzepte}
\subsection{Grammatikbeschreibung}

\section{Weitere Technologien}
\subsection{Kotlin}
Kotlin ist eine von JetBrains entwickelte Programmiersprache \cite{KotlinReference}. Kotlin zeichnet besonders durch die kompakte Syntax und starke Integration in das bestehende Java-Umfeld aus. Zusätzlich bietet Kotlin Absicherungen gegen \lstinline{NullPointerExceptions} zur Compile-Zeit. Wie bei Java wird aus Kotlin beim Kompilieren ebenfalls Bytecode für die JVM (Java Virtual Machine) erzeugt. Durch diese enge Interoperabilität kann beim Programmieren mit Kotlin auf die bereits große Menge an Java-Bibliotheken zurückgegriffen werden.

Bei MiniJava wird Kotlin als Implementierungssprache des MiniJava-Compilers eingesetzt. Der von ANTLR generierte Parser (Java-Sourcecode) lässt sich von Kotlin ausgehend problemlos verwenden Kotlin aufgrund persönlicher Präferenz gewählt, da die tatsächliche Implementierungssprache des Compilers im JVM-Umfeld keine essenzielle Rolle spielt.

\subsection{Node.js}
Node.js ist eine JavaScript-Laufzeitumgebung, die auf der V8 JavaScript Engine aufbaut \cite{NodeJSDocumentation}. Node.js wird unter anderem bei skalierbaren Serveranwendungen eingesetzt, die möglichst viele Verbindungen gleichzeitig abarbeiten können sollen. Node.js unterstützt die JavaScript-Schnittstelle für WebAssembly (siehe Abschnitt TODO).

Bei MiniJava wird Node.js als Laufzeitumgebung für Konsolenanwendungen eingesetzt.

\subsection{JavaScript}
JavaScript ist eine Skriptsprache, die zur Laufzeit interpretiert wird \cite{MDNJavaScript}. Bekannt ist sie vor allem als clientseitige Programmiersprache im Browser für Webseiten. JavaScript ist prototyp-basiert und dynamisch typisiert. Weiters besitzt JavaScript nur eine Handvoll an Datentypen, darunter \lstinline{number} für Ganz- und Fließkommazahlen, \lstinline{string} für Zeichenketten, \lstinline{boolean} für Wahrheitswerte, \lstinline{function} für Funktionen und \lstinline{object} für jede Art von Objekt inklusive Arrays. Der Sprachumfang von JavaScript basiert auf der ECMAScript-Spezifikation.

JavaScript dient bei MiniJava als Bindeglied zu WebAssembly.

\subsection{Gradle}
Gradle ist ein Build-System, das sich im Java-Umfeld etabliert hat \cite{Gradle}. Der Build-Prozess wird dabei deklarativ in der Programmiersprache Groovy beschrieben.

Das Kernelement sind so genannte Tasks, die eine definierte Aufgabe erfüllen, beispielsweise Java-Code kompilieren, Tests ausführen oder ein Java-Archiv (JAR) erstellen. Zwischen Tasks lassen sich Abhängigkeiten definieren, dadurch werden Tasks in der richtigen Reihenfolge abgearbeitet (zum Beispiel Tests müssen nach dem Kompilieren ausgeführt werden). Weiters können für Tasks Eingaben und Ausgaben (das sind Order bzw. Dateien) definiert werden. Mit diesen Informationen kann Gradle den Build-Prozess dahingehend optimieren, dass nur diejenigen Tasks ausgeführt werden, bei denen es auch sinnvoll ist: Beispielsweise würde es nichts bringen, Java-Sourcecode nocheinmal zu kompilieren, wenn er sich seit dem letzten Kompilieren nicht verändert hat.

Gradle baut auf der Abhängigkeitsverwaltung von Maven auf. So lassen sich bestehende Bibliotheken, die zum Beispiel im Central Repository\footnote{\url{https://search.maven.org}} verfügbar sind, einfach einbinden.

Bei MiniJava wird Gradle bei der gesamten Implementierung dieser Masterarbeit eingesetzt, sowohl beim Kompilieren des MiniJava-Compilers selbst, als auch beim Kompilieren von MiniJava-Sourcecode mit dem MiniJava-Compiler.

\subsection{webpack}
webpack ist ein Werkzeug, mit dem mehrere JavaScript-Module, die auf mehrere Dateien aufgeteilt sind, in eine einzige JavaScript-Datei zusammengebündelt werden können \cite{Webpack}. webpack unterstützt eine Reihe von Modulsystemen, darunter CommonJS (mit Statement \lstinline{require}) oder die \lstinline{import}-Statements im ES2015-Umfeld. Weiters kann webpack auch so konfiguriert werden, dass andere Programmiersprachen (wie zum Beispiel TypeScript) ebenfalls in diesen Prozess eingebunden werden können. Diese müssen dabei mit einem Transpiler in JavaScript-Sourcecode konvertiert werden.

Bei MiniJava wird webpack eingesetzt, um beim Einsatz im Browser alle (generierten) JavaScript-Dateien in eine gemeinsame JavaScript-Datei zusammenzufassen.

\subsection{JUnit und AssertJ}
JUnit ist ein Unit-Test-Framework für Java \cite{JUnit}. Testfälle können sehr einfach definiert werden, es genügt dabei eine Methode mit der \lstinline{@Test}-Annotation zu markieren, dann kann sie von JUnit gefunden werden. Weiters lässt sich JUnit direkt in Gradle als Teil des Build-Prozesses integrieren \cite{Gradle}.

AssertJ ist eine Bibliothek zum Schreiben von Assertionen. JUnit bietet diese Funktionalität bereits, jedoch ist der wesentliche Vorteil gegenüber JUnit, dass die Assertionen fast wie ein englischer Satz aussehen. Nachfolgend ein Beispiel dazu:

\lstinputlisting{src/technischeGrundlagen/assertions.java}

Auch wenn der Code etwas länger ist, ist er aussagekräftiger. Außerdem würde man sofort erkennen, wenn man den erwarteten und den tatsächlichen Wert vertauschen würde.

JUnit wird gemeinsam mit AssertJ bei MiniJava zum Testen des Compilers eingesetzt.

\section{Stand der Technik}
Es gibt bereits eine Reihe an Technologien, die auf WebAssembly aufbauen. In diesem Abschnitt werden drei ausgewählte aktuelle Technologien betrachtet. Es wird dabei der Fokus auf den Einsatz der Technologien und der Art der Integration mit WebAssembly und JavaScript gelegt.

\subsection{Emscripten}

Emscripten ist ein Compiler, mit dem sich C/C++-Sourcecode nach WebAssembly übersetzen lässt \cite{Emscripten}. Die grundsätzliche Idee ist, dass sich mit möglichst wenig Aufwand bestehender Code ins Web bringen lässt. Zum Beispiel werden \lstinline{printf}-Aufrufe automatisch auf die Konsole abgebildet. Weitere typische Bibliotheken werden direkt unterstützt, darunter zum Beispiel SDL (Simple DirectMedia Layer) OpenGL (über WebGL) oder OpenAL (über Web Audio API). Emscripten bietet zusätzlich eine Reihe an eigenen Schnittstellen an, darunter zum Beispiel Anbindungen an HTML 5 und WebVR.

Da WebAssembly in einem isolierten Umfeld läuft, ergeben sich natürlich auch einige Einschränkungen, die keine 1:1-Abbildungen ermöglichen, dazu zählen zum Beispiel direkter Dateisystem- und Netzwerkzugriff. Für Netzwerkanbindungen bietet Emscripten zum Beispiel eine Schnittstelle für WebSockets an. Dateisystemzugriff wird über ein virtuelles Dateisystem abgebildet. Auf dieses virtuelle Dateisystem kann wie gewohnt über Funktionen wie \lstinline{fopen} zugegriffen werden. Dateien können entweder statisch beim Kompilieren in dieses Dateisystem oder zur Laufzeit dynamisch über XMLHttpRequests geladen werden.

Mit Emscripten sind Aufrufe von JavaScript nach C möglich. Funktionen werden in C mit \lstinline{EMSCRIPTEN_KEEPALIVE} markiert, damit sie durch Optimierungen nicht gelöscht werden, falls sie nirgends in C referenziert werden. In JavaScript gibt es zwei Möglichkeiten zum Aufruf: Direkt an das Modul mit einem Unterstrich vor dem Funktionsnamen oder über \lstinline{ccall}. Nachfolgend findet sich ein auf der offziellen Dokumentation basierendes Code-Beispiel.

\lstinputlisting[caption = Aufruf einer C-Funktion in JavaScript]{src/technischeGrundlagen/emscriptenCCalls.txt}

Es ist auch möglich, C++-Funktionen aufzurufen, dies ist aber aufgrund von Name mangling nicht so einfach wie bei C-Funktionen möglich. Eine Lösung für dieses Problem ist das "Verpacken" in \lstinline|extern "C" { ... }| Konstrukte. Weitere Möglichkeiten sind in der offiziellen Dokumentation zu finden.

Aufrufe von C nach JavaScript sind auch möglich. Grundsätzlich bietet Emscripten hier zwei Ansätze: Das Ausführen von beliebigen JavaScript-Sourcecode-Strings (wird vom JavaScript über \lstinline{eval} ausgewertet) oder das Einbetten von JavaScript-Sourcecode in C. Nachfolgend findet sich ein auf der offziellen Dokumentation basierendes Code-Beispiel.

\lstinputlisting[caption = Aufruf von JavaScript in C]{src/technischeGrundlagen/emscriptenJSCalls.txt}

\subsection{Blazor WebAssembly}
Blazor \cite{Blazor} ist ein von Microsoft entwickeltes Framework und eine Technologie in der ASP.NET Core Familie. Mit Blazor lassen sich clientseitige Web-Anwendungen auf Basis von .NET mit C\#{} entwickeln. Blazor wird in zwei Ausprägungen angeboten: Blazor Server und Blazor WebAssembly. Weitere Ausprägungen für Progressive-Web-Apps, mobile Anwendungen auf Basis von Web-Technologien und native Anwendungen sind geplant \cite{BlazorBlog}.

Blazor basiert auf Razor \cite{Razor}. Razor ermöglicht, HTML und C\#{} miteinander zu kombinieren. Nachfolgend ist ein Code-Beispiel, das das Zusammenspiel zwischen HTML und C\#{} verdeutlichen soll.

\lstinputlisting[caption = Beispiel für eine Blazor-Komponente aus der offiziellen Dokumenation \cite{Blazor}]{src/technischeGrundlagen/blazorExample.razor}

Man sieht, dass sich Werte aus Variablen ausgeben lassen können (\lstinline{@Title}) und Maus\-klick-Ereignisse auf Methodenaufrufe abgebildet werden können (\lstinline{@onclick="OnYes"}). Weiters lassen sich andere Komponenten einbinden (\lstinline{@ChildContent}).

Blazor Server wird, wie der Name bereits erahnen lässt, serverseitig betrieben. Dabei läuft die Logik der Web-Anwendung auf dem Server. Die Kommunikation zwischen Server und Browser erfolgt über SignalR. Das bedeutet, dass jedes Ereignis und jedes Update der Benutzeroberfläche über das Netzwerk erfolgt. Blazor Server wurde hier nur zur Vollständigkeit erwähnt und wird nicht weiter behandelt.

Bei der zweiten Variante, Blazor WebAssembly, wird keine Logik mehr am Server ausgeführt. Der Weg vom Code zur lauffähigen Anwendung sieht folgendermaßen aus: Der Code wird zu .NET-Assemblies kompiliert. Der Browser lädt diese Assemblies und die .NET-Laufzeit-Umgebung von einem Web-Server herunter. Die .NET-Lauf\-zeit\-um\-ge\-bung läuft in der virtuellen WebAssembly-Maschine und lädt die Assemblies. In diesem Prozess gibt es eine Reihe an Optimierungen, zum Beispiel wird die .NET-Laufzeitumgebung im Cache des Browsers ablegt, um unnötige Downloads zu ersparen.

Blazor basiert auf dem .NET Standard 2.0. Somit kann bestehender Code, der diesen Standard erfüllt, wiederverwendet werden. Gewisse Funktionaliäten dieses Standards werden jedoch nicht unterstützt, dazu zählt beispielsweise direkter Dateisystemzugriff und Threading. In diesen Fällen kommt es zu einem Laufzeitfehler.

Weiters bietet Blazor Schnittstellen an, um von JavaScript ausgehend .NET-Methoden aufzurufen und umgekehrt. Nachfolgend finden sich zwei Codeausschnitte, die die Interoperabilität veranschaulichen sollen. Sie basieren auf der offiziellen Dokumentation und wurden auf die wesentlichen Bestandteile zusammengefasst.

\lstinputlisting[caption = Aufruf einer JavaScript-Funktion in C\#{} \cite{Blazor}]{src/technischeGrundlagen/blazorJSCalls.txt}

\lstinputlisting[caption = Aufruf einer C\#{}-Methode in JavaScript \cite{Blazor}]{src/technischeGrundlagen/blazorCSharpCall.txt}

\subsection{Rust}

Die Programmiersprache Rust verspricht auf der eigenen Website \cite{RustWasmWebsite} Unterstützung für WebAssembly. Dabei werden sticht besonders hervor, dass zur Laufzeit kein Garbage-Collector involviert ist, die Ausführzeiten somit vorhersehbar werden und der Rust-Compiler in der Lage ist, möglichst kleine WebAssembly-Module zu generieren.

Der Weg vom Rust-Code zur Webanwendung sieht folgendermaßen aus: Der Rust-Sourcecode wird mit cargo in ein WebAssembly-Modul kompiliert. Anschließend wird mit wasm-bindgen JavaScript-Code generiert. Das Werkzeug wasm-pack fasst diese Aufgaben zusammen \cite{RustWasmBook}.

Um Rust-Sourcecode im WebAssembly-Umfeld verwenden zu können, sind einige Anpassungen im Code notwendig. Nachfolgend findet sich ein einfaches Code-Beispiel (basierend auf der offiziellen Dokumentation \cite{RustWasmBook}), das die Interopabilität zwischen Rust und JavaScript demonstrieren soll.

\lstinputlisting[caption = Rust-Sourcecode für WebAssembly angepasst]{src/technischeGrundlagen/rustLib.rs}

Zunächst muss die Speicherverwaltung konfiguriert werden. Dafür wird \lstinline{wee_alloc} (The Wasm-Enabled, Elfin Allocator) eingesetzt. Dieser erzeugt besonders wenig WebAs\-sembly-Bytecode, laut offizieller Dokumentation unter einem Kilobyte und ist für WebAssembly ausgelegt \cite{WeeAlloc}.

Mit dem Attribut \lstinline{#[wasm_bindgen]} können Funktionalitäten von JavaScript importiert (hier die Funktion \lstinline{alert} in Kombination mit \lstinline{extern}) werden. Es ist auch möglich, Datenstrukturen und Funktionen für JavaScript zugänglich zu machen (hier die Datenstruktur \lstinline{Point} und die Funktionen \lstinline{Point.new} und \lstinline{alert_point}).

Aus diesen Informationen kann wasm-pack JavaScript-Code erzeugen, der sehr einfach verwendet werden kann:

\lstinputlisting[caption = Verwendung eines Rust-Moduls in JavaScript ]{src/technischeGrundlagen/rustJS.js}

Sämtliche Daten (wie die Instanz der Struktur \lstinline{Point}) werden im eigenen Speicherbereich für WebAssembly abgelegt (siehe Abschnit TODO). Es wird nur die Adresse des hinterlegten Rust-Objekts in einem JavaScript-Objekt gekapselt. Dieses JavaScript-Objekt delegiert sämtliche Funktionsaufrufe an WebAssembly.
